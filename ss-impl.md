# 分析shadowsocks协议的工作原理
### 1. 本文目的
Shadowsocks协议最初版本由@clawwindy设计，用于突破防火墙检测的加密协议。现由一群开源爱好者维护，目前看来使用一直比较稳定，本文试图解释其背后工作原理和实现的一些技术细节。SS协议的设计非常简洁高效，不过其功能非常有限，除向内或是向外突破防火墙功能之外几乎没有别的功能。这种简洁设计也许正是其一直无法有效检测封锁的原因。本文试图从原理上分析其设计和并结合shadowsocks-libev的实现源码分析其工作机制。
### 2. socks5代理的工作方式简介
要想理解SS的工作方式，首先要理解传统socks5代理的工作方式。socks5代理协议是[RFC 1928](https://tools.ietf.org/html/rfc1928)确定的一种标准协议，其工作方式由标准决定当然不能随意更改，否则会造成使用协议客户端的兼容性问题。实现一个简单的socks5代理并不困难，一个基本的实现参考这里[socks5实现](https://github.com/fgssfgss/socks_proxy),其基本工作原理是在服务器开启一个服务并监听端口，当客户端按socks5协议确定的方式与服务器握手建立连接后，服务器记录下客户端的相关信息，这与unix标准网络套接字通讯没有区别。假设我们的服务器是S客户端是C,客户端C想通过服务器S与另一台主机A进行通讯，客户端C首先生成与A通讯要使用的数据包，其中头部包含A的地址，A的通讯端口和相关控制参数，包内空就是要通讯的数据。此时C要知道自己是使用代理通讯，因此自己按照socks5协议规定的方式修改原TCP数据包的格式以符合下列规则

        +----+-----+-------+------+----------+----------+---------+
        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT | Data    |
        +----+-----+-------+------+----------+----------+---------+
        | 1  |  1  | X'00' |  1   | Variable |    2     | Variable|
        +----+-----+-------+------+----------+----------+---------|

          o  VER    protocol version: X'05'
          o  CMD
             o  CONNECT X'01'
             o  BIND X'02'
             o  UDP ASSOCIATE X'03'
          o  RSV    RESERVED
          o  ATYP   address type of following address
             o  IP V4 address: X'01'
             o  DOMAINNAME: X'03'
             o  IP V6 address: X'04'
          o  DST.ADDR       desired destination address
          o  DST.PORT desired destination port in network octet
             order
在服务器S接收到此数据包后，在服务器生成两个套接字F1和F2，(F1,F2)这个二元组相当于记录了一条C与A的TCP连接或UDP连接链路，服务器把C发来的数据包修改源地址等相关参数后转发给A，此后S与A再尝试建立TCP或UDP连接并转发数据。当A回传会数据给S时，S将其拆包封装后按照socks5协议转发给C。在服务器S中实际上是建立了一条管道帮助C与A之间传送数据。socks5协议中有一个地方值得注意，就是这个*ATYP*字段，TCP/UDP协议本身目标地址与源地址都只能以IP地址为端点，是不能支持域名这类hostname参数的。域名到地址的转换要通过DNS协议来完成，那么就有了两种选择。第一种是客户端C自己通过DNS查询出相应域名对应的IP地址，之后填写目标地址为IP地址。或是直接填写域名地址，让代理服务器S去请求DNS服务器进行域名解析并相应修改管理数据包的正确传输。DNS一般采用UDP协议传输，第一种方向经过的节点少相应的延迟低，但是会泄露一部分数据，毕竟请求的主机解析记录可能被链路上的路由器、嗅探器、DNS服务器等感知。第二种方式经过的节点变多但是链路上的中间节点没有办法直接拿到主机解析记录。socks5协议本身不涉及传送内容加密，所有传输的数据都是明文传送，因此在互联网上传送非常容易被防火墙分析出传送数据内容或是切断链路。
### 3. TLS协议的工作方式简介
TLS全称安全传输层协议,实际上从传输层看来TLS完全是运行在TCP/IP之上的应用层协议。而对于上层运行在TLS之上的应用层协议看来它又像是传输层协议。TLS是基于非对称加密钥机制和公钥加密体系之上的加密传输协议，实际上TLS之上传输的数据是用对称流加密算法加密的。非对称密钥只在协商密钥和验证公钥阶段使用。TLS的基础设施实现比较复杂，这里没有办法展开介绍，但是它实现的主要功能却是异常重要的，基本可以概括如下：当Alice和Bob在不可能的链路上通讯时，Eve处在链路之间，可以修改、丢弃或伪造双向数据包。在这种情况下TLS依旧可以保障传输数据不可被Eve伪造并且不可被Eve进行身份欺骗(identity authentication),数据伪造(data integrity)或是解密数据(privacy)。目前主流的TLS协议是TLSv1.2版，尽管TLS协议可以保证信息传送的安全性和保密性，但在实际上TLS在使用中还是泄露不少信息的，比如会让链路嗅探者很容易判断出你在使用TLS协议通讯甚至协议的版本都可以判断出来，这是因为TLS协议在设计之初主要是为了保证前面提到的三个通讯安全问题而不致力于隐藏自己或是穿透防火墙，因此TLS设计上没有考虑对自身协议特征的隐藏。在http协议运行在TLS之上时，有一些应用上的TLS扩展也是会泄露大量的信息，其中比较重要的是SNI(Server Name Indication)扩展，它会泄露用户请求的域名信息，这虽然不会造成用户传输数据本身的泄露风险，但是对用户隐私的泄露也是非常大的。当TLS运行在socks代理服务器之上时会遇到一点技术细节的问题。当C通过TLS协议请求A的内容时，服务器S要通过TCP包的头部特征识别出这是一个TLS包，TLS包的头部包含一个SNI字段，代理根据这个字段解析出目标服务器的IP地址，之后再封包转发数据给A,当然也可以由C本身先解析出地址之后传送给代理服务器S。但是即使这样也要携带上SNI字段的，因为一般服务器都在在一个IP上部署很多网站，服务器要根据这个字段判断用户请求的资源到底是什么(vhost机制)。TLS的加密和安全特性使其在互联网上不断普及，因此在使用代理服务器时也可以放心访问目标网站资源不用怕代理服务器本身是不安全的。

### 4. shadowsocks的工作方式

要理解SS协议首先要理解SS的设计目标。SS本身的设计目标是穿透防火墙并反协议识别，因此SS的服务器要设计成在外界看来没有任何特征的应用服务器，SS与客户端的通讯流量要保证无法破解的同时看起来没有明显的特征，通过SS服务端与客户端的流量比特要符合平均随机分布和条件平均随机分布，就是说要与随机传送的比特流熵保持一致。在SS引入了AEAD算法之后服务器状态一直工作在流加密模式下(当然在ss-local与ss-server建立TCP连接之初未验证第一个加密的流数据包之前服务器处在初始化状态)。

SS的设计思路是将原socks5代理拆成两个部分，一个客户端ss-local和一个服务器ss-server。ss-local生成socks5接口供应用程序使用，而ss-local与ss-sever之间通过精心设计的强加密算法和隐藏算法通讯，核心的功能层还是以socks5代理的工作方式一样。当然shadowsocks-libev使用了libev通过异步非阻塞的方式控制套接字的数据读写，可以以非常高的效率让低端的设备也可以轻松无压力运行，具体工作模式如下图:

![shadowsocks](https://user-images.githubusercontent.com/1621543/42849657-b106c2f6-8a56-11e8-9999-701295d8b7ef.png)

TLS的实现是在密钥协商阶段通过多次握手实现，这个明显的特征让识别TLS的握手流量变得非常容易，如果SS也采用协商握手的方式实现将会暴露出明显的特征。为了反识别SS协议的设计放弃了握手式的密钥协商机制，而是采用预设共享密钥(PSK)的方式完成握手。
ss-local在每次向服务器发送SS协议握手包时会随机生成一个salt，这个随机salt在每次连接(建立TCP连接)服务器时随机生成一个，ss-local发给服务器的握手数据包大概是如下格式,其中的salt是随机生成的。服务器通过使用预设密钥并配合salt使用密钥提升算法生成强密钥(这个过程使用的参数和ss-local使用的方法一致并且生成的相同强共享密钥)，之后用强共享密钥解密消息。每一次调用解密过程者会让解密序列号加1，这个序列号的功能是让相同的消息再加密一次会变得完全没有相似性。最新的shadowsocks版本使用的加密解密算法是AEAD功能函数，这个种算法的特性是在解密过程中一次性验证数据是不是被篡改过并验证共享密钥的有效性。ss-local发给的ss-server服务器的数据包格式如下:


	+----------------------------+--------------+---------------------+---------------+
	|   encrypted payload length |   length tag | encrypted payload   |   payload tag |
	+============================+==============+=====================+===============+
	|                          2 |           16 | Variable            |            16 |
	+----------------------------+--------------+---------------------+---------------+

注意当第一次建立连接时的数据包前面会包含一个随机的salt,站在ss-local与ss-server中间来看，数据总是不定长度且符合平均分布随机bit流的特性，所以并不能有效区分出哪个是携带了salt字段的数据流，看起来都是一串随机的字节流传送。服务器在建立TCP连接之后将第一个数据包的前8个byte做为salt,之后调用AEAD的解密算法进行解密并验证授权，如果授权成功就算握手成功，如果验证授权失败就断开连接。以后的流模式传送过程中依旧如此，任何一次的AEAD解密验证授权失败都会断开连接。
SS也支持UDP协议的转发，UDP包是如下格式。

	+--------+---------------------+-------+
	|   salt | encrypted payload   |   tag |
	+========+=====================+=======+
	|      8 | Variable            |    16 |
	+--------+---------------------+-------+
其中的salt与TCP中的不同，每个UDP数据报文前8个字节都是当做本次解密的salt,因为UDP传输的不可靠性，当AEAD算法解密失败后并不会开始拒绝之后的UDP数据包的继续发送，服务器仅仅是丢弃这个不合法的数据包。

*注意：*
在SS协议的设计中服务器不会给客户端返回出错信息，因此如果客户端使用了错误的密码或是因为加密配置与服务器不匹配，服务器不会返回给客户端提示信息，这种静默行为可以极大减小服务器可识别的特征。

### SS服务器设计缺陷和SIP004草案
在SS加入AEAD算法之前，SS的开发者团队发现了ss-server中存在一个行为特征可供CCA(选择密文攻击)探测攻击的潜在漏洞并且第一次修正之后引入了OTA特性，后来发现OTA是一个更大的漏洞，因此团队发起SIP004设计草案引入AEAD算法一次解决验证问题并彻底对抗CCA攻击。新方案与原来的流数据格式不再兼容，因此属于新的协议方案。要理解为什么引入使用AEAD加密算法新协议的技术细节，有必要看一下原来的协议是如何设计的。

	+-------------+---------------------+
	| Random IV   | encrypted payload   |
	+=============+=====================+
	| Fixed       | Variable            |
	+-------------+---------------------+
这是原协议的握手数据包，其中Random IV是随机生成的初始化向量，密文是通过使用预共享密钥和这个Random IV加密的，加解密函数原型如下
S_Encrypt(IV,PSK,message) => (ciphertext)
S_Decrypt(IV,PSK,ciphertext) => (message)
解密后的message对应如下数据包：

	+--------------+---------------------+------------------+----------+
	| Address Type | Destination Address | Destination Port |   Data   |
	+--------------+---------------------+------------------+----------+
	|      1       |       Variable      |         2        | Variable |
	+--------------+---------------------+------------------+----------+

问题原因是SS采用的加密方式是流加密并且明文有固定的结构，这里的Address Type只有socks5协议中固定的三种可能数值：01, 03, 04，那么对于同样的IV和PSK只可能有三种加密后的模式，这个位置长度是一个byte，攻击者可以截获加密消息之后固定修改密文的对应的这一个byte的所有256种可能组合之后传送给服务器，SS加密算法不能对密文本身进行验证，任意构造的密文都可以用来解密，至于解密后的明文是不是合法的消息要下一步验证。在攻击者构造的这256种密文中只有3种是合法的，其它的都因为不合法造成服务器直接断开TCP连接，当然服务器可以等待随机时间再断开连接但是这不是密码学意义上的安全设计。

为了对抗这种CCA攻击，目前项目维护者@madeye提出了OTA(One Time Auth)一次性验证协议,握手包和数据包的解密后格式如下:

	+------+---------------------+------------------+-----------+
	| ATYP | Destination Address | Destination Port | HMAC-SHA1 |
	+------+---------------------+------------------+-----------+
	|  1   |       Variable      |         2        |    10     |
	+------+---------------------+------------------+-----------+

	+----------+-----------+----------+----
	| DATA.LEN | HMAC-SHA1 |   DATA   | ...
	+----------+-----------+----------+----
	|     2    |     10    | Variable | ...
	+----------+-----------+----------+----

对于是否开启OTA功能在ATYP的高位未使用部分设置了一个bit进行标记(ATYP & 0x10 == 0x10)，其中HMAC-SHA1用来对数据进行校验。但是这种修改依旧不能阻止CCA攻击，甚至攻击变得更加方便了。攻击者只要随机修改DATA.LEN部分对应的密文，服务器会因为长度变化有一部分时间会继续等待套接字传送接下来的数据直到超时(当然这个数据并不存在所以会导致超时),攻击者可以通过这种timing测量的CCA攻击方式识别SS服务器的这个特性。因此SS项目维护组成员提出了必须启动一次解密操作同时验证数据完整性和可信性的加密算法，由此在项目中引入了AEAD加密算法，新算法加入后客户端与服务器没有了握手数据包和流数据包的区别。

### AEAD算法在SS中的具体工作流程

客户端ss-local在与服务器建立连接之前生成一个随机的定长字串salt,之后使用密钥提升算法函数HKDF_SHA1(key, salt, info) => subkey 来生成强密钥，其中key是用户事先设置的共享密钥(PSK),info是固定的字串内容"ss-subkey"(不包含双引号)。在ss-local程序启动的时候，因为它本身没有办法验证与服务器连接是否合法，所以它启动过程中并没有必要与服务器进行连接。它只会在接收到第一个socks5代理请求时才开始尝试与服务器ss-server建立连接，当与服务器TCP握手完成后它发送的第一个数据包一个salt(明文传送)后面附带若干SS协议确定的流格式数据包。服务器第一次接收到ss-local的此消息时会把salt记录下来当所这次session的共享salt,当TCP连接关闭之后这个salt会作废。AEAD使用的加密函数定义如下:

AE_encrypt(key, nonce, message) => (ciphertext, tag)

AE_decrypt(key, nonce, ciphertext, tag) => message

算法加密和解密中使用的nonce相当于序号的作用，这个序号在ss-local与ss-server是要同步的。在TCP连接中因为协议会控制数据包丢失重传，因此这个序号可以保证使用ss-local使用加密后增加1(nonce本身是个二进制字串，增加1是定义的一种操作，类似整数加法，当然也可以直接使用整数加法)。每次服务端调用一次解密函数时nonce也自增1，这样ss-local客户端的加密nonce与与ss-server服务端的解密nonce就达到了同步。同样的原理ss-server的加密nonce与ss-local的解密nonce也用此方法同步。对于UDP连接，服务端与客户端使用的nonce是固定为所有位都置于零的状态(UDP转发功能使用每个数据报前的随机salt做到相同的message每次加密对应不同的密文(这里面貌似会产生一个replay攻击的问题，还没有具体验证过)。

在ss-local与ss-server的任何两次不同的TCP连接之间，绝对不会使用相同的salt，否则会带来安全风险。注意这个数据包的salt是随机生成，后面的附带数据也都是AEAD算法生成的与随机白噪声等熵的二进制字串，因此整个流数据都保证与白噪声数据流等熵，不可能通过分析这个数据流内容特征来判断出传送的是SS协议。服务器在接收到数据流之后使用相同的密钥提升算法，相同的PSK,salt和info来生成subkey。AEAD算法本身附带认证算法，当解密失败后，会根据错误类型确认客户端不合法，之后断开TCP连接。

关于UDP数据包其中的域名解析DNS数据包是特殊处理的，大部分浏览器支持设置代理启用代理服务器负责DNS解析，但是有一些浏览器根本没有提供这样的选项或是实现不正确。个人经过测试发现firefox通过浏览器启用socsk5代理可以勾选通过代理服务器解析DNS，但是firefox通过插件switchomega设置的代理却不能通过代理服务器解析DNS。实际上如果浏览器配置不正确非常容易让防火墙通过客户端的行为识别出SS服务器并进行封锁IP或是端口。毕竟当一个客户端发送大量的防火墙内不能访问的host解析，同时又与境外单一服务器或少数服务器进行长连接大流量通讯，这是十分可疑的行为。这就是客户端使用行为上的特征让识别SS服务器成为可能的一个突破口，所以就算ss-server和ss-local配置没有问题，浏览器配置使用不当也是可能造成ss-server地址和通讯端口被识别到。

### 主要源码逻辑
ss-local的实现主逻辑在local.c源文件中，主要用来管理连接的结构体是listen_ctx,server_t和remote_t，这个server_t并不是与ss-server服务器对应的server,listen_ctx里才是包含了和ss-server服务器通讯参数与本地监听参数配置等信息的结构体。server_t对应的是本地生成的socks5代理服务器每个来连接的客户端。而每个server_t内部管理了一组remote_t列表，每个remote_t结构体对应着每个客户端通过代理与远程服务器建立的TCP连接。在ss-server中也有listen_ctx,server_t和remote_t结构，其中listen_ctx对应ss-server进程监听的端口预设共享密码等信息。server_t对应每个ss-local与此ss-server建立的连接，remote_t对应某个ss-local通过与ss-server的连接通过代理转发的TCP连接。在ss-local与ss-server中对数据的转发处理通过libev的回调机制封装，此异步非阻塞模式可以极大增加吞吐量。
加密部分主要是基于tlsmbed库和libsodium库，AEAD加密算法的封装在aead.c源文件和aead.h头文件中
	![image](https://user-images.githubusercontent.com/1621543/42848730-28daa99a-8a53-11e8-89ae-ce5b64833ff4.png)
其中AES128GCM，AES192GCM，AES256GCM算法来自tls-mbed库，CHACHA20POLY1305IETF和XCHACHA20POLY1305IETF算法来自libsodium库。CHACHA20POLY1305IETF算法设计来自谷歌，在服务器和嵌入式平台都有非常不错的性能。AES算法有很大的性能问题，只有在支持AES扩展的CPU上才能达到理想的性能。因此推荐默认使用CHACHA20POLY1305IETF算法。
加密接口封装在源文件crypto.c和头文件crypto.h中，初始化完毕后crypto_t结构体封装了加解密函数和状态,cipher_ctx_t封装了针对每个客户端加解密机制的salt,key等状态。
	![image](https://user-images.githubusercontent.com/1621543/42849439-c35dced2-8a55-11e8-96a7-c40b72d75311.png)

对于AEAD协议之前的流加密协议，对应的加密操作都封装在源文件stream.c和头文件stream.h中，原来非AEAD协议还是存在明显的潜在缺陷的，因此在可能的情况下尽量选择AEAD算法下的新协议。

### 目前SS主要的安全缺陷和功能缺陷
SS协议的设计前提假设是用户自己架设服务器并只有少量用户使用，用户会保管好PSK。在这个假设满足的前提下SS协议本身目前并没有发现明显的安全缺陷，但是当这些条件不满足的情况下，SS还是暴露出明显的安全缺陷。当第三方知道了PSK并且可以监听通讯链路的情况下，可以实施完整的中间人攻击，中间人可以完整窃取解密后的通讯的内容。中间人甚至可以伪造钓鱼服务器，在没有其它加密协议如TLS的保护下，可以篡改通讯内容。即使在有TLS保护的情况下依旧可以可以读取TLS扩展如SNI中暴露的隐私内容。当黑客或是机构攻陷或控制了某些可信CA的私钥之后，可以在这样的SS钓鱼服务器上使用可信CA签发伪造的证书来窃取完整TLS通讯内容或是直接篡改内容，这是一种目标非常明确的单点攻击，这反而比需要控制和监听大量流量节点更加节省攻击资源。

功能上SS缺乏类似SSH服务器的多种双向检测认证机制，SSH服务器在首次连接后会保存服务器的签名信息(ECDSA),以后每次连接都会检测服务器的指纹信息保证服务器非伪造，实际上SS严重缺乏这样的几只，当另人知道了你的PSK之后很容易伪造一台服务器而客户端连接时完全没有办法判断服务器是伪造的。SS服务器在同一个PSK和端口配置下没有办法区分不同的用户，这对用户管理和QOS限制造成很大的困难。

个人觉得SS协议可以扩展为包含一个控制码在encrypted payload中，将SSH协议的部分特性如ECDSA和RSA密钥对功能引入其中完善其功能同时增强安全性。

### 总结
SS协议的设计简洁高效，虽然目前还没有形成标准并且也没有安全团队对协议进行形式化验证，但是SS服务器的部署数量非常巨大和广泛。DockerHub上最高的SS服务器镜像拉取次数超过千万次。而且因为协议简洁高效，不少语言和环境都实现了相应遥客户端和服务端，就算是计算资源非常有限的嵌入式设备也没有问题。希望这个协议可以尽快固定并标准化下来，让一些应用程序可以直接集ss-local后端模块，支持SS协议代理连接服务器，至于具体保密性可以让TLS协议走在SS代理之上。

### 参考
【1】https://github.com/shadowsocks/shadowsocks-libev

【2】https://shadowsocks.org/en/spec/Implementations.html

【3】https://blessing.studio/why-do-shadowsocks-deprecate-ota/

【4】https://tools.ietf.org/html/rfc1928

【5】https://bingtaoli.github.io/2016/11/23/shadowsocks%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/


